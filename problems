Why is it ok to allow related prefix of 1 to stop the search for more prefixes, but not the same for suffixes and roots appearing later?
if 'a' returns 14 related results we keep going, then 'an' returns 1 related result, we can stop at an


Anatomy of a word: Preffix - root - suffix

Redesign the dissect() method based on these rules:
https://www.mpc.edu/home/showdocument?id=12804
Rule 1:
A word can be made of just roots and roots can appear beginning middle or end of a word. Example: Geo- -logy
Rule 2: 
A word can have more than one root prefix or suffix. Example: 
Rule 3:
A suffix can appear in the middle or the end, but never the beginning of a word.
Rule 4:
A prefix can appear in the beginning or the middle, but never the end of a word.
Rule 5:
The spelling of roots may change as they are combined with suffixes.
Rule 6: 
Sometimes you may identify a group of letters as a prefix or root but find that it does not
carry the meaning of that prefix or root.  For example, the letters mis in missile are part of the root and are not the prefix mis-, which
means “wrong; bad.”
Rule 7:
Words do not always have a root, prefix or a suffix. They will always have at least one type, but may be missing the other two types of parts.


How this app will be when finished:

 -> menu with one tab. Default tab will be 'search'
 -> search lets you start typing a medical term and the app will begin finding the closest matches. If the user declines to click any of the matches and there is no exact match for the word when they hit enter, it will perform the actual term dissection. However it will not add the term to main table, instead it will add the term to a review table. A review words table where I can review words that were searched. The more commonly a word is searched the more likely I will be to add it to the real table with an actual definition and the dissected meanings. Then permanently this word will always show up as a match if it is typed by the user and dissect method will be skipped.
 -> However, if a user does select a word as a match, or a exact match exists for the term they are searching, then instead of running the actual dissect method it saves time and performance by simply pulling up the existing data in the database based on previous dissections of that word. 
 -> If a meaning of a word or affix is incorrect according to a user, there is a button called 'This doesn't look right" if they click that, then they will be given a form to fill out with the words which they felt were wrong, and their suggestion for correcting. This form submits to a `corrections` table which I will review manually.
 -> If during the dissecting phase of a new term, more than one affixes match exactly for a single part of a word, then the matches will be shown to the user and they can choose which they think is more likely to be correct based on the meaning. This means a meaning of the actual term will also be searched online and provided from wikipedia or google dictionary etc...and shown to the user to help them decide. Whatever they decide is recorded in the `review words` table.




select replace(replace(replace(affix, "(", ""), ")", ""), "-", "") from affix;   // turns '-hyp(o)' into 'hypo'
alter table affix add readAffix varchar(100) as (replace(replace(replace(affix, "(", ""), ")", ""), "-", "")) invisible;

//Not needed:
select regexp_replace(replace(replace(replace(affix, "(", ""), ")", ""), "-", ""), "\\[[0-9]\\]", "") from affix;  // turns 'hypo[7]' into 'hypo'


There are several bugs with my method of finding the correct affix in the database.

#1: It keeps going until only one exists, which means it skips the shorter one even if that is the correct one.
Example: analgesic 'an' retrieves ana- and an-, which means 2 are left, so it adds another letter until only one is left so it does 'ana' which retrieves 'ana' only. But 'ana' is the incorrect affix. 'an' is the correct one. because 'an-' means 'anal'.
Solution: Make it choose the shorter option momentarily, and then check to see if the following affix actually finds an affix matching the full thing, and if it doesn't then it starts over and this time it chooses the larger option. That way 'an' will choose 'an-' first, and if 'algesi' cannot find a match in the database, then it starts over and chooses 'ana-' and then tries 'lgesi'. But it shouldn't ever get that far because in this case it should find 'algesi'.
But the question is, when should it begin checking for that? Should it be when the results are 5 or less? What if 10 words exist which contain 'an'?
Problem: This kind of illustrates how some words mash affixes together into one. But as long as the variations are specified it shouldn't be a big deal. 

#2: Sometimes there are affixes which are not listed in my database. Even after I have added as many affixes as I can from online sources in my database.
Solution: Simply make the algorithm either return the closest possible match, or have it return null if nothing close could be found. Also allow users to add the affix manuallly to the database if they believe it is real and is simply missing from the database.

#3: Sometimes there are variations to affixes which do not exist in my database.
Example: analgesic. The affix for '-alge(si)' matches everything except the 'c' at the end. For this problem its easy to fix because 'c' doesn't find anything so it's not considered a part. But in other examples it could be a variation inside the affix itself. 
Solution: Add the variation to the affix database, or make a algorithm which chooses the most similar affix in case it's more than 1 letter, and if that is not correct allow users to change or add the correct variation to the database manually.

#4: Sometimes there are base(root) words which are used inside medical terms which are not listed in my database since my table only has prefixes and suffixes.
Example: antibody  'anti-' is a medical affix, but 'body' is a full english word, not a affix.
Solution: Simply add roots to the table or add a full english dictionary which gets checked in case a medical affix or root word cannot be found.

#5: Sometimes there are general english affixes used inside medical terms which are not listed in my medical affixes database.
Example: 'hypovolemia', '-vol' is not a medical affix it is a general english affix. 
Solution: Simply add a general english affixes table to the medical term affixes so that both can be checked at the same time, so that these problems do not occur anymore. If a affix is used it should always be found in the database.

#6: Sometimes a single affix can have more than one entry in my database. 
Example 'an-' appears in the first record for 'a-, an-' meaning 'not, without'. But it also appears on its own record as 'an-' meaning 'anus'. 
Solution: The only way to solve this problem is to introduce more context for the computer to decide which 'an-' record is the correct one. The best context I can give is the definition of the completed word which 'an-' appears in. So 'analgesic' is 'A medication that reduces or eliminates pain.' This obviously has nothing to do with rear ends. So as a human I know the answer must be the first record 'a, an-' meaning 'not, without', but how does the computer know? It will have to calculate based on the synonyms of the words in the definition. For example, relief may be a synonym for not or without, but in reality, it is not. So this method still does not work.
If I cannot find a way to do this successfully, then I will have to resort to choosing affixes for words manually and letting users make requests for updates to words that may be incorrect.

At this point, I'm starting to think it is impossible to give the computer correct context for all cases, and so I might rely on users to pick up the slack, but for the most part I will try to make the algorithm work as best as it can to get the closest possible answer. If it's wrong, users will be able to raise the issue and I'll be able to update it manually so that the program is forced to choose the correct answer instead of using the algorithm. But it would be nice if it were possible to get the algorithm to work in all cases. Though at this point I'm starting to think that is not possible.
Another option I have, is to simply skip making an algorithm altogether and instead manually create the correct affixes for each medical term online, but this comes with a problem. One, it is showing employers that I couldn't make a decent algorithm which is kind of the whole point of this app. two: It also means that it will take me 10x longer to develop this app and have it mostly completed. 

So here is what I think I will do instead. If I can work on making my algorithm work in 75% of cases, then that is good enough for me. And then the rest we will fill in manually when someone tries to search for a word that fails to get the correct affixes/root words and meanings.


